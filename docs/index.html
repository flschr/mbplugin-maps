<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Micro.blog Maps Validator</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha512-Zcn6bjR/8RZbLEpLIeOwNtzREBAJnUKESxces60Mpoj+2okopSAcSUIUOseddDm0cxnGQzxIR7vJgsLZbdLE3w=="
      crossorigin="anonymous"
    />
    <style>
      :root {
        font-family: "Inter", "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
        color: #0f172a;
        line-height: 1.6;
      }

      body {
        margin: 0;
        min-height: 100vh;
        background: #ffffff;
      }

      .page {
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      header {
        padding: clamp(1.5rem, 3vw, 2.25rem) clamp(1rem, 3vw, 2.25rem) clamp(1.25rem, 3vw, 1.75rem);
        text-align: center;
        max-width: 960px;
        margin: 0 auto;
        width: 100%;
      }

      header h1 {
        margin: 0 0 0.5rem;
        font-size: clamp(1.85rem, 4vw, 2.65rem);
        font-weight: 700;
        letter-spacing: -0.01em;
      }

      header p {
        margin: 0;
        max-width: 640px;
        color: #475569;
        font-size: 0.98rem;
      }

      main {
        flex: 1;
        width: 100%;
        display: flex;
        justify-content: center;
      }

      .layout {
        display: grid;
        grid-template-columns: minmax(260px, 320px) minmax(0, 1fr);
        gap: clamp(1.25rem, 3vw, 2rem);
        align-items: start;
        padding: 0 clamp(1rem, 3vw, 2.25rem) clamp(2rem, 5vw, 3rem);
        max-width: 960px;
        width: 100%;
        margin: 0 auto;
        box-sizing: border-box;
      }

      .config-panel {
        display: flex;
        flex-direction: column;
        gap: 1.25rem;
      }

      form {
        display: grid;
        gap: 0.85rem;
        padding: clamp(1rem, 2.25vw, 1.5rem);
        border: 1px solid #dce3f1;
        border-radius: 14px;
        background: #ffffff;
        box-shadow: 0 10px 20px rgba(15, 23, 42, 0.05);
      }

      form label {
        display: grid;
        gap: 0.25rem;
        font-size: 0.82rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: #334155;
      }

      form input,
      form textarea {
        font: inherit;
        padding: 0.45rem 0.65rem;
        border-radius: 10px;
        border: 1px solid #cbd5f5;
        background: #ffffff;
        color: inherit;
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
        resize: vertical;
      }

      form textarea {
        min-height: 80px;
      }

      form input:focus,
      form textarea:focus {
        outline: none;
        border-color: #4f46e5;
        box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.18);
      }

      button[type="submit"] {
        justify-self: start;
        padding: 0.55rem 1.25rem;
        border-radius: 999px;
        border: none;
        font-weight: 600;
        font-size: 0.95rem;
        cursor: pointer;
        background: linear-gradient(135deg, #4f46e5, #38bdf8);
        color: #ffffff;
        box-shadow: 0 8px 16px rgba(79, 70, 229, 0.25);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      button[type="submit"]:hover {
        transform: translateY(-1px);
        box-shadow: 0 12px 22px rgba(79, 70, 229, 0.25);
      }

      .snippet-card {
        padding: clamp(1rem, 2.25vw, 1.5rem);
        border-radius: 14px;
        border: 1px solid #dce3f1;
        background: #ffffff;
        box-shadow: 0 10px 22px rgba(15, 23, 42, 0.05);
        display: flex;
        flex-direction: column;
        gap: 0.6rem;
      }

      .snippet-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.75rem;
      }

      .snippet-header h2 {
        margin: 0;
        font-size: 0.92rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: #475569;
      }

      #copy-shortcode {
        padding: 0.45rem 1.1rem;
        border-radius: 999px;
        border: none;
        background: #0f172a;
        color: #ffffff;
        font-weight: 600;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 0.3rem;
        transition: background 0.2s ease, transform 0.2s ease;
      }

      #copy-shortcode:hover {
        background: #1e293b;
        transform: translateY(-1px);
      }

      pre {
        margin: 0;
        padding: 0.9rem 1rem;
        border-radius: 12px;
        background: #0f172a;
        color: #f8fafc;
        font-size: 0.92rem;
        overflow-x: auto;
        min-height: 96px;
        display: flex;
        align-items: flex-start;
      }

      pre code {
        font-family: "JetBrains Mono", "Fira Code", "SFMono-Regular", Menlo, Consolas, monospace;
        white-space: pre-wrap;
        word-break: break-word;
      }

      .field-hint {
        margin: 0;
        font-size: 0.75rem;
        font-weight: 500;
        letter-spacing: normal;
        text-transform: none;
        color: #b45309;
      }

      .styles-note {
        margin: 0;
        grid-column: 1 / -1;
        font-size: 0.82rem;
        color: #475569;
        text-align: center;
      }

      .styles-note a {
        color: #2563eb;
        font-weight: 600;
      }

      .preview-card {
        display: flex;
        flex-direction: column;
        gap: 0.65rem;
        background: #ffffff;
        border: 1px solid #dce3f1;
        border-radius: 14px;
        padding: clamp(0.9rem, 1.8vw, 1.25rem);
        box-shadow: 0 10px 20px rgba(15, 23, 42, 0.05);
      }

      .preview-card label {
        display: grid;
        gap: 0.25rem;
        font-size: 0.8rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: #334155;
      }

      .preview-card select {
        font: inherit;
        padding: 0.4rem 0.6rem;
        border-radius: 8px;
        border: 1px solid #cbd5f5;
        background: #ffffff;
        color: inherit;
      }

      .map-frame {
        position: relative;
        width: 100%;
        border-radius: 12px;
        overflow: hidden;
        min-height: 220px;
        background: #e2e8f0;
        aspect-ratio: 4 / 3;
      }

      .leaflet-container {
        width: 100%;
        height: 100%;
      }

      .status-message {
        margin: 0;
        font-size: 0.86rem;
        color: #0f172a;
        min-height: 1.25rem;
      }

      .status-message[data-state="loading"] {
        color: #2563eb;
      }

      .status-message[data-state="error"] {
        color: #dc2626;
      }

      .status-message[data-state="success"] {
        color: #047857;
      }

      .status-message[data-state="notice"] {
        color: #b45309;
      }

      @media (max-width: 900px) {
        .layout {
          grid-template-columns: 1fr;
        }

        .snippet-header {
          flex-direction: column;
          align-items: flex-start;
        }

        #copy-shortcode {
          width: 100%;
          justify-content: center;
        }
      }
    </style>
  </head>
  <body>
    <div class="page">
      <header>
        <h1>Micro.blog Maps Validator</h1>
        <p>
          Preview your <code>{{&nbsp;map&nbsp;}}</code> shortcode, explore Geoapify map styles, and copy the finished snippet for your post.
        </p>
      </header>
      <main>
        <div class="layout">
          <div class="config-panel">
            <form id="map-config">
              <label>
                Location / coordinates
                <input type="text" name="loc" value="Berlin, Germany" placeholder="e.g. 52.5200, 13.4050" required />
              </label>
              <label>
                Zoom level (1–18)
                <input type="number" name="zoom" min="1" max="18" value="12" />
              </label>
              <label class="has-hint">
                Geoapify API key (required)
                <input
                  type="text"
                  name="tile-key"
                  id="tile-key"
                  autocomplete="off"
                  placeholder="Paste your required Geoapify key to load live styles"
                  required
                />
                <p class="field-hint" id="geoapify-hint"></p>
              </label>
              <label>
                Marker text
                <input
                  type="text"
                  name="marker"
                  placeholder="Optional description for the marker"
                  value="Brandenburg Gate"
                />
              </label>
              <button type="submit">Refresh preview</button>
            </form>

            <div class="snippet-card">
              <div class="snippet-header">
                <h2>Shortcode</h2>
                <button type="button" id="copy-shortcode" aria-live="polite">Copy snippet</button>
              </div>
              <pre><code id="shortcode-output"></code></pre>
              <p class="status-message" id="status-message" role="status"></p>
            </div>
          </div>

          <div class="preview-card">
            <label>
              Preview style
              <select id="style-select"></select>
            </label>
            <div class="map-frame" id="map-preview"></div>
          </div>
          <p class="styles-note">
            Need a reference? Browse the official
            <a href="https://apidocs.geoapify.com/docs/icon/learn-more/" target="_blank" rel="noopener">Geoapify map style catalog</a>
            to see thumbnails for every style identifier.
          </p>
        </div>
      </main>
    </div>

    <script
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      integrity="sha512-BwHfrr4c9kmRkLw6iXFdzcdWV/PGkVgiIyIWLLlTSXzWQzxuSg4DiQUCpauz/EWjgk5TYQqX/kvn9pG1NpYfqg=="
      crossorigin="anonymous"
    ></script>
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        const geoapifyStyles = [
          { value: 'osm-carto', label: 'Geoapify · OSM Carto' },
          { value: 'osm-bright', label: 'Geoapify · OSM Bright' },
          { value: 'osm-bright-grey', label: 'Geoapify · OSM Bright Grey' },
          { value: 'osm-bright-smooth', label: 'Geoapify · OSM Bright Smooth' },
          { value: 'klokantech-basic', label: 'Geoapify · Klokantech Basic' },
          { value: 'osm-liberty', label: 'Geoapify · OSM Liberty' },
          { value: 'maptiler-3d', label: 'Geoapify · MapTiler 3D' },
          { value: 'toner', label: 'Geoapify · Toner' },
          { value: 'toner-grey', label: 'Geoapify · Toner Grey' },
          { value: 'positron', label: 'Geoapify · Positron' },
          { value: 'positron-blue', label: 'Geoapify · Positron Blue' },
          { value: 'positron-red', label: 'Geoapify · Positron Red' },
          { value: 'dark-matter', label: 'Geoapify · Dark Matter' },
          { value: 'dark-matter-brown', label: 'Geoapify · Dark Matter Brown' },
          { value: 'dark-matter-dark-grey', label: 'Geoapify · Dark Matter Dark Grey' },
          { value: 'dark-matter-dark-purple', label: 'Geoapify · Dark Matter Dark Purple' },
          { value: 'dark-matter-purple-roads', label: 'Geoapify · Dark Matter Purple Roads' },
          { value: 'dark-matter-yellow-roads', label: 'Geoapify · Dark Matter Yellow Roads' }
        ];

        const fallbackTiles = {
          url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
          options: {
            maxZoom: 19,
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
          }
        };

        const geoapifyTileOptions = {
          maxZoom: 20,
          attribution:
            'Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors · Tiles &copy; <a href="https://www.geoapify.com/">Geoapify</a>'
        };

        const storageKey = 'mb-map-validator-geoapify-key';
        let storedTileKey = '';
        try {
          storedTileKey = localStorage.getItem(storageKey) || '';
        } catch (error) {
          storedTileKey = '';
        }

        const form = document.getElementById('map-config');
        const shortcodeOutput = document.getElementById('shortcode-output');
        const copyButton = document.getElementById('copy-shortcode');
        const statusMessage = document.getElementById('status-message');
        const styleSelect = document.getElementById('style-select');
        const geoapifyHint = document.getElementById('geoapify-hint');
        const tileKeyInput = document.getElementById('tile-key');
        const previews = [];

        if (tileKeyInput && storedTileKey) {
          tileKeyInput.value = storedTileKey;
        }

        function buildGeoapifyTileUrl(styleId) {
          if (!styleId) {
            return null;
          }
          const apiKey = tileKeyInput ? tileKeyInput.value.trim() : '';
          if (!apiKey) {
            return null;
          }
          return 'https://maps.geoapify.com/v1/tile/' + styleId + '/{z}/{x}/{y}.png?apiKey=' + encodeURIComponent(apiKey);
        }

        function getTileConfig(style) {
          const tileUrl = buildGeoapifyTileUrl(style.value);
          if (!tileUrl) {
            return {
              url: fallbackTiles.url,
              options: Object.assign({}, fallbackTiles.options),
              usingFallback: true
            };
          }

          return {
            url: tileUrl,
            options: Object.assign({}, geoapifyTileOptions),
            usingFallback: false
          };
        }

        function refreshGeoapifyHint() {
          if (!geoapifyHint) {
            return;
          }
          const needsKey = previews.some(function(preview) {
            return preview.usingFallback;
          });
          if (needsKey) {
            geoapifyHint.textContent =
              'A Geoapify API key is required to load these map styles. Enter your key above to replace the OpenStreetMap fallback tiles.';
          } else {
            geoapifyHint.textContent = '';
          }
        }

        function populateSelect(select, defaultValue) {
          geoapifyStyles.forEach(function(style) {
            const option = document.createElement('option');
            option.value = style.value;
            option.textContent = style.label;
            select.appendChild(option);
          });
          select.value = defaultValue;
        }

        populateSelect(styleSelect, 'osm-carto');

        function createPreview(select, containerId) {
          const map = L.map(containerId, { zoomControl: true });
          const preview = {
            map: map,
            select: select,
            currentLayer: null,
            marker: null,
            handleTileError: null,
            usingFallback: false
          };

          previews.push(preview);

          function applyStyle(styleValue) {
            const style = geoapifyStyles.find(function(item) {
              return item.value === styleValue;
            }) || geoapifyStyles[0];

            if (preview.currentLayer) {
              if (preview.handleTileError) {
                preview.currentLayer.off('tileerror', preview.handleTileError);
                preview.handleTileError = null;
              }
              preview.map.removeLayer(preview.currentLayer);
            }

            const config = getTileConfig(style);
            const layer = L.tileLayer(config.url, config.options || {});
            preview.currentLayer = layer;
            preview.usingFallback = config.usingFallback;

            if (!config.usingFallback) {
              const handleTileError = function() {
                layer.off('tileerror', handleTileError);
                preview.map.removeLayer(layer);
                const fallbackLayer = L.tileLayer(fallbackTiles.url, fallbackTiles.options || {});
                fallbackLayer.addTo(preview.map);
                preview.currentLayer = fallbackLayer;
                preview.usingFallback = true;
                preview.handleTileError = null;
                refreshGeoapifyHint();
              };
              preview.handleTileError = handleTileError;
              layer.on('tileerror', handleTileError);
            } else {
              preview.handleTileError = null;
            }

            layer.addTo(preview.map);
            refreshGeoapifyHint();
          }

          preview.applyStyle = applyStyle;

          select.addEventListener('change', function() {
            applyStyle(select.value);
          });

          applyStyle(select.value);
          return preview;
        }

        createPreview(styleSelect, 'map-preview');

        function parseCoordinates(value) {
          if (!value) {
            return null;
          }
          const parts = value.split(',');
          if (parts.length !== 2) {
            return null;
          }
          const lat = parseFloat(parts[0]);
          const lng = parseFloat(parts[1]);
          if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
            return null;
          }
          return { lat: lat, lng: lng };
        }

        function updateShortcode() {
          const loc = form.loc.value.trim();
          const zoom = form.zoom.value.trim();
          const marker = form.marker.value.trim();
          let snippet = '{{< map';
          if (loc) {
            snippet += ' loc="' + loc.replace(/"/g, '\\"') + '"';
          }
          if (zoom) {
            snippet += ' zoom="' + zoom + '"';
          }
          if (marker) {
            snippet += ' marker="' + marker.replace(/"/g, '\\"') + '"';
          }
          snippet += ' >}}';
          shortcodeOutput.textContent = snippet;
          shortcodeOutput.dataset.code = snippet;
        }

        function setStatus(message, state) {
          statusMessage.textContent = message || '';
          if (state) {
            statusMessage.dataset.state = state;
          } else {
            statusMessage.removeAttribute('data-state');
          }
        }

        function updateMarker(preview, latlng, markerText) {
          if (!preview.marker) {
            preview.marker = L.marker(latlng).addTo(preview.map);
          } else {
            preview.marker.setLatLng(latlng);
          }

          if (markerText) {
            preview.marker.bindPopup(markerText);
          } else {
            preview.marker.unbindPopup();
          }
        }

        function updatePreviews(latlng, zoom, markerText) {
          previews.forEach(function(preview) {
            preview.map.setView(latlng, zoom);
            updateMarker(preview, latlng, markerText);
            preview.map.invalidateSize();
          });
        }

        function handleSuccess(latlng, zoom, markerText) {
          updatePreviews(latlng, zoom, markerText);
          setStatus('Preview updated.', 'success');
        }

        function geocodeLocation(loc, zoom, markerText) {
          const coords = parseCoordinates(loc);
          if (coords) {
            handleSuccess(coords, zoom, markerText);
            return;
          }

          setStatus('Looking up the location …', 'loading');
          const url = 'https://nominatim.openstreetmap.org/search?format=jsonv2&limit=1&q=' + encodeURIComponent(loc);
          fetch(url, {
            headers: {
              'Accept-Language': navigator.language || 'en'
            },
            referrerPolicy: 'no-referrer-when-downgrade'
          })
            .then(function(response) {
              if (!response.ok) {
                throw new Error('Location search failed.');
              }
              return response.json();
            })
            .then(function(result) {
              if (!Array.isArray(result) || result.length === 0) {
                throw new Error('No results for "' + loc + '".');
              }
              const item = result[0];
              const lat = parseFloat(item.lat);
              const lng = parseFloat(item.lon);
              if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
                throw new Error('Received invalid coordinates.');
              }
              handleSuccess({ lat: lat, lng: lng }, zoom, markerText);
            })
            .catch(function(error) {
              setStatus(error.message || 'Could not load the location.', 'error');
            });
        }

        form.addEventListener('submit', function(event) {
          event.preventDefault();
          const loc = form.loc.value.trim();
          const zoom = Math.min(18, Math.max(1, parseInt(form.zoom.value, 10) || 12));
          const markerText = form.marker.value.trim();
          updateShortcode();
          geocodeLocation(loc, zoom, markerText);
        });

        form.addEventListener('input', function() {
          updateShortcode();
        });

        copyButton.addEventListener('click', function() {
          const code = shortcodeOutput.dataset.code || shortcodeOutput.textContent || '';
          if (!code) {
            return;
          }
          navigator.clipboard
            .writeText(code)
            .then(function() {
              setStatus('Shortcode copied to clipboard.', 'success');
            })
            .catch(function() {
              setStatus('Could not copy automatically. Please copy manually.', 'error');
            });
        });

        // Initial render
        updateShortcode();
        const initialLoc = form.loc.value.trim();
        const initialZoom = parseInt(form.zoom.value, 10) || 12;
        const initialMarker = form.marker.value.trim();
        geocodeLocation(initialLoc, initialZoom, initialMarker);

        function persistTileKey(value) {
          try {
            if (value) {
              localStorage.setItem(storageKey, value);
            } else {
              localStorage.removeItem(storageKey);
            }
          } catch (error) {
            // ignore persistence errors
          }
        }

        if (tileKeyInput) {
          tileKeyInput.addEventListener('input', function() {
            const key = tileKeyInput.value.trim();
            persistTileKey(key);
            previews.forEach(function(preview) {
              preview.applyStyle(preview.select.value);
            });
          });
        }
      });
    </script>
  </body>
</html>
